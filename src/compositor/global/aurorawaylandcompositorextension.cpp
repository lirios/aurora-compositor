// Copyright (C) 2021 The Qt Company Ltd.
// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0-only

#include "aurorawaylandcompositorextension.h"
#include "aurorawaylandcompositorextension_p.h"

#include <QtCore/QCoreApplication>
#include <QtCore/QDebug>

#include <wayland-server-core.h>

namespace Aurora {

namespace Compositor {

/*!
 * \class WaylandCompositorExtensionTemplate
 * \inmodule AuroraCompositor
 * \since 5.8
 * \brief WaylandCompositorExtensionTemplate is a convenience class for subclassing
 * WaylandCompositorExtension.
 *
 * WaylandCompositorExtensionTemplate is a template class which inherits
 * WaylandCompositorExtension and is convenience for building custom Wayland extensions with Qt.
 *
 * It provides the connection between Qt Wayland Compositor and the class generated by
 * \c qtwaylandscanner, based on the XML description of the extension protocol.
 *
 * It provides two specific pieces of convenience:
 * \list
 *   \li A reimplementation of \l{WaylandCompositorExtension::extensionInterface()} which returns
 *   the \c wl_interface pointer for the qtwaylandscanner-generated base class.
 *   \li A static \l{findIn()} function which searches for an instance of the extension in a
 *   provided container, and returns this if it is found.
 * \endlist
 *
 * Typically, a new extension will dual-inherit WaylandCompositorExtensionTemplate and the class
 * generated by \c qtwaylandscanner.
 *
 * WaylandCompositorExtensionTemplate should be parameterized with the subclass itself:
 * \code
 * class MyExtension
 *     : public WaylandCompositorExtensionTemplate<MyExtension>
 *     , PrivateServer::my_extension
 * \endcode
 *
 * In this example, \c MyExtension is an implementation of the generated interface \c my_extension.
 *
 * \sa {Custom Shell}
 */

/*!
 *  \fn template <typename T> T *WaylandCompositorExtensionTemplate<T>::findIn(WaylandObject *container)
 *
 *  If any instance of the interface has been registered with \a container, this is returned.
 *  Otherwise null is returned. The look-up is based on the generated \c interfaceName() which
 *  matches the interface name in the protocol description.
 */

/*!
 * \class WaylandCompositorExtension
 * \inmodule AuroraCompositor
 * \since 5.8
 * \brief WaylandCompositorExtension is the base class for compositor extensions.
 *
 * WaylandCompositorExtension is the base class for implementing Wayland extensions on the
 * compositor-side of the connection. If no other extension container is explicitly set, it will
 * automatically add itself to its parent object, granted that this inherits from WaylandObject.
 *
 * For example, for registering global extensions, you can inherit from WaylandCompositorExtension
 * and pass the WaylandCompositor object as extension container.
 *
 * \sa WaylandCompositorExtensionTemplate, {Custom Shell}
 */

/*!
 * Creates a WaylandCompositorExtension with no container.
 *
 * \sa setExtensionContainer()
 */
WaylandCompositorExtension::WaylandCompositorExtension()
    : WaylandObject(*new WaylandCompositorExtensionPrivate())
{
}

/*!
 * Creates a WaylandCompositorExtension and adds it to the extension \a container. The \a container
 * does not become the parent of the WaylandCompositorExtension.
 *
 * The extension adds itself to \a container later, when \l{initialize()} is called. For this to
 * happen automatically, an event loop must be running in the current thread.
 *
 * The WaylandCompositorExtension will remove itself again when it is destroyed.
 */
WaylandCompositorExtension::WaylandCompositorExtension(WaylandObject *container)
    : WaylandObject(*new WaylandCompositorExtensionPrivate())
{
    d_func()->extension_container = container;
    QCoreApplication::postEvent(this, new QEvent(QEvent::Polish));
}

WaylandCompositorExtension::WaylandCompositorExtension(WaylandCompositorExtensionPrivate &dd)
    : WaylandObject(dd)
{
}

WaylandCompositorExtension::WaylandCompositorExtension(WaylandObject *container, WaylandCompositorExtensionPrivate &dd)
    : WaylandObject(dd)
{
    d_func()->extension_container = container;
    QCoreApplication::postEvent(this, new QEvent(QEvent::Polish));
}

WaylandCompositorExtension::~WaylandCompositorExtension()
{
    Q_D(WaylandCompositorExtension);
    if (d->extension_container)
        d->extension_container->removeExtension(this);
}

/*!
 *  \fn const wl_interface *WaylandCompositorExtension::extensionInterface() const
 *
 *  A pure virtual function which should be reimplemented to return the \c wl_interface which
 *  corresponds to this WaylandCompositorExtension.
 */

/*!
 * \return the extension container for this WaylandCompositorExtension or null if none has been
 * set.
 */
WaylandObject *WaylandCompositorExtension::extensionContainer() const
{
    Q_D(const WaylandCompositorExtension);
    return d->extension_container;
}

/*!
 * Sets the extension container for this WaylandCompositorExtension to \a container. This must be
 * called before \l{initialize()} and cannot be changed once the WaylandCompositorExtension has
 * been initialized.
 */
void WaylandCompositorExtension::setExtensionContainer(WaylandObject *container)
{
    Q_D(WaylandCompositorExtension);
    d->extension_container = container;
}

/*!
 * Initializes the WaylandCompositorExtension. The default implementation adopts the parent object
 * as extension container if none has been set, and if the parent inherits from WaylandObject. The
 * default implementation also adds the WaylandCompositorExtension to the list of extensions
 * managed by the extension container.
 *
 * Override this function in subclasses to provide custom initialization code.
 */
void WaylandCompositorExtension::initialize()
{
    Q_D(WaylandCompositorExtension);
    if (d->initialized) {
        qWarning() << "WaylandCompositorExtension:" << extensionInterface()->name << "is already initialized";
        return;
    }

    if (!d->extension_container && parent()) {
        WaylandObject *parentObj = qobject_cast<WaylandObject*>(parent());
        if (parentObj)
            setExtensionContainer(parentObj);
    }

    if (!d->extension_container) {
        qWarning() << "WaylandCompositorExtension:" << extensionInterface()->name << "requests to initialize with no extension container set";
        return;
    }

    d->extension_container->addExtension(this);
    d->initialized = true;
}

bool WaylandCompositorExtension::isInitialized() const
{
    Q_D(const WaylandCompositorExtension);
    return d->initialized;
}

bool WaylandCompositorExtension::event(QEvent *event)
{
    switch(event->type()) {
    case QEvent::Polish:
        if (!isInitialized())
            initialize();
        break;
    default:
        break;
    }
    return WaylandObject::event(event);
}

/*!
 * \class WaylandObject
 * \inmodule AuroraCompositor
 * \since 5.8
 * \brief WaylandObject is the base class for objects that can contain Wayland extensions.
 *
 * The WaylandObject encapsulate extension container functionality. Any WaylandObject object
 * will automatically be an extension container and WaylandCompositorExtension object which is
 * a child of this will automatically add itself to its extension list, and remove itself when
 * the extension object is destroyed.
 */

/*!
 *  Creates a WaylandObject as a child of \a parent.
 */
WaylandObject::WaylandObject(QObject *parent)
    :QObject(parent)
{
}

WaylandObject::WaylandObject(QObjectPrivate &d, QObject *parent)
    :QObject(d, parent)
{
}


WaylandObject::~WaylandObject()
{
    for (WaylandCompositorExtension *extension : std::as_const(extension_vector))
        WaylandCompositorExtensionPrivate::get(extension)->extension_container = nullptr;
}

/*!
 *  Returns the compositor extension which matches \a name if one has been registered with the
 *  WaylandObject. If no extension matching the name has been registered, this function returns
 *  null.
 */
WaylandCompositorExtension *WaylandObject::extension(const QByteArray &name)
{
    for (int i = 0; i < extension_vector.size(); i++) {
        if (extension_vector.at(i)->extensionInterface()->name == name)
            return extension_vector.at(i);
    }
    return nullptr;
}

/*!
 *  Returns the compositor extension which matches \a interface if one has been registered with the
 *  WaylandObject. If no extension matching the interface has been registered, this function
 *  returns null.
 */
WaylandCompositorExtension *WaylandObject::extension(const wl_interface *interface)
{
    for (int i = 0; i < extension_vector.size(); i++) {
        if (extension_vector.at(i)->extensionInterface() == interface)
            return extension_vector.at(i);
    }
    return nullptr;
}

/*!
 *  Returns the list of compositor extensions that have been registered with this WaylandObject.
 */
QList<WaylandCompositorExtension *> WaylandObject::extensions() const
{
    return extension_vector;
}

/*!
 *  Registers \a extension with this WaylandObject.
 */
void WaylandObject::addExtension(WaylandCompositorExtension *extension)
{
    Q_ASSERT(!extension_vector.contains(extension));
    extension_vector.append(extension);
}

/*!
 *  Removes \a extension from the list of registered extensions in this WaylandObject, if it has
 *  previously been registered using \l{addExtension()}.
 */
void WaylandObject::removeExtension(WaylandCompositorExtension *extension)
{
    if (!extension->isInitialized())
        return;
    Q_ASSERT(extension_vector.contains(extension));
    extension_vector.removeOne(extension);
}

} // namespace Compositor

} // namespace Aurora

#include "moc_aurorawaylandcompositorextension.cpp"
